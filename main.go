package main

/////////////////////////////////////////////////////////////////
//Code generated by chidley https://github.com/gnewton/chidley //
/////////////////////////////////////////////////////////////////

import (
	"encoding/xml"
	//"flag"
	"fmt"
	//"github.com/davecheney/profile"
	"github.com/jinzhu/gorm"
	"log"
	//	"net/http"
	"os"
	"strconv"
	"time"
)

var filename = "/home/gnewton/newtong/work/pubmedDownloadXmlById/aa/pubmed_xml_26419650"

const TransactionSize = 100000
const ArticleBufferSize = 1
const chunkSize = 50000
const CommentsCorrections_RefType = "Cites"

func init() {

}

var out int = -1

var counters map[string]*int

const PUBMED_ARTICLE = "PubmedArticle"

func main() {

	//defer profile.Start(profile.CPUProfile).Stop()

	db, err := dbInit()
	if err != nil {
		log.Fatal(err)
		return
	}
	defer func() {
		err = db.Close()
		if err != nil {
			log.Fatal(err)
		}
	}()

	articleChannel := make(chan []*Article)

	done := make(chan bool)

	go articleAdder(articleChannel, done, db, TransactionSize)
	count := 0
	chunkCount := 0
	arrayIndex := 0
	for i, filename := range os.Args {
		if i == 0 {
			continue
		}
		log.Println("Opening: " + filename)
		log.Println(strconv.Itoa(i) + " of " + strconv.Itoa(len(os.Args)))
		reader, _, err := genericReader(filename)

		if err != nil {
			log.Fatal(err)
			return
		}
		articleArray := make([]*Article, chunkSize)

		decoder := xml.NewDecoder(reader)
		counters = make(map[string]*int)

		for {

			token, _ := decoder.Token()
			if token == nil {
				break
			}
			switch se := token.(type) {
			case xml.StartElement:
				if se.Name.Local == PUBMED_ARTICLE && se.Name.Space == "" {
					if count%10000 == 0 && count != 0 {
						fmt.Println("------------")
						fmt.Println(count)
						fmt.Println(arrayIndex)
						fmt.Println("------------")
					}

					count = count + 1
					var pubmedArticle ChiPubmedArticle
					decoder.DecodeElement(&pubmedArticle, &se)
					article := pubmedArticleToDbArticle(&pubmedArticle)
					if article == nil {
						log.Println("nil")
						continue
					}
					articleArray[arrayIndex] = article
					arrayIndex = arrayIndex + 1
					if arrayIndex >= chunkSize {
						log.Printf("Sending chunk %d", chunkCount)
						chunkCount = chunkCount + 1
						//pubmedArticleChannel <- &pubmedArticle

						articleChannel <- articleArray
						log.Println("Sent")
						articleArray = make([]*Article, chunkSize)
						arrayIndex = 0
					}
				}
			}
		}
	}
	close(articleChannel)
	_ = <-done

}

func pubmedArticleToDbArticle(p *ChiPubmedArticle) *Article {
	medlineCitation := p.ChiMedlineCitation
	pArticle := medlineCitation.ChiArticle
	if pArticle == nil {
		return nil
	}

	dbArticle := new(Article)
	dbArticle.Id, _ = strconv.ParseInt(p.ChiMedlineCitation.ChiPMID.Text, 10, 64)
	dbArticle.Abstract = ""
	//if pArticle !=pArticle.ChiAbstract != nil && pArticle.ChiAbstract.ChiAbstractText != nil {
	if pArticle.ChiAbstract != nil && pArticle.ChiAbstract.ChiAbstractText != nil {
		for i, _ := range pArticle.ChiAbstract.ChiAbstractText {
			dbArticle.Abstract = dbArticle.Abstract + " " + pArticle.ChiAbstract.ChiAbstractText[i].Text
		}
	}

	dbArticle.Title = pArticle.ChiArticleTitle.Text
	if pArticle.ChiArticleDate != nil {
		dbArticle.Year, _ = strconv.Atoi(pArticle.ChiArticleDate.ChiYear.Text)
		dbArticle.Month = pArticle.ChiArticleDate.ChiMonth.Text
		dbArticle.Day, _ = strconv.Atoi(pArticle.ChiArticleDate.ChiDay.Text)
	}

	if medlineCitation.ChiCommentsCorrectionsList != nil {
		actualCitationCount := 0
		for _, commentsCorrection := range medlineCitation.ChiCommentsCorrectionsList.ChiCommentsCorrections {
			if commentsCorrection.Attr_RefType == CommentsCorrections_RefType {
				actualCitationCount = actualCitationCount + 1
			}
		}

		dbArticle.Citations = make([]Citation, actualCitationCount)
		counter := 0
		for _, commentsCorrection := range medlineCitation.ChiCommentsCorrectionsList.ChiCommentsCorrections {
			if commentsCorrection.Attr_RefType == CommentsCorrections_RefType {
				citation := new(Citation)
				citation.Pmid, _ = strconv.ParseInt(commentsCorrection.ChiPMID.Text, 10, 64)
				citation.RefSource = commentsCorrection.ChiRefSource.Text
				dbArticle.Citations[counter] = *citation
				counter = counter + 1
			}
		}

	}

	if medlineCitation.ChiChemicalList != nil {
		dbArticle.Chemicals = make([]Chemical, len(medlineCitation.ChiChemicalList.ChiChemical))
		for i, chemical := range medlineCitation.ChiChemicalList.ChiChemical {
			dbChemical := new(Chemical)
			dbChemical.Name = chemical.ChiNameOfSubstance.Text
			dbChemical.Registry = chemical.ChiRegistryNumber.Text
			dbArticle.Chemicals[i] = *dbChemical
		}

	}

	if medlineCitation.ChiMeshHeadingList != nil {
		dbArticle.MeshTerms = make([]MeshTerm, len(medlineCitation.ChiMeshHeadingList.ChiMeshHeading))
		for i, mesh := range medlineCitation.ChiMeshHeadingList.ChiMeshHeading {
			dbMesh := new(MeshTerm)
			dbMesh.Descriptor = mesh.ChiDescriptorName.Text
			//dbMesh.Qualifier = mesh.ChiQualifierName.Text
			dbArticle.MeshTerms[i] = *dbMesh
		}
	}

	if pArticle.ChiJournal != nil {
		journal := new(Journal)
		journal.Title = pArticle.ChiJournal.ChiTitle.Text
		if pArticle.ChiJournal.ChiISSN != nil {
			journal.Issn = pArticle.ChiJournal.ChiISSN.Text
		}
		dbArticle.Journal = *journal
	}

	if pArticle.ChiAuthorList != nil {
		dbArticle.Authors = make([]Author, len(pArticle.ChiAuthorList.ChiAuthor))
		for i, author := range pArticle.ChiAuthorList.ChiAuthor {
			dbAuthor := new(Author)
			if author.ChiIdentifier != nil {
				//dbAuthor.Id = author.ChiIdentifier.Text
			}
			if author.ChiLastName != nil {
				dbAuthor.LastName = author.ChiLastName.Text
			}
			if author.ChiForeName != nil {
				dbAuthor.FirstName = author.ChiForeName.Text
			}
			dbArticle.Authors[i] = *dbAuthor
		}
	}

	return dbArticle
}

func articleTransformer(pubmedArticleChannel chan []*ChiPubmedArticle, articleChannel chan []*Article) {
	for pubmedArticleArray := range pubmedArticleChannel {
		log.Println("-- transformer Consuming chunk")
		articleArray := make([]*Article, len(pubmedArticleArray))
		for i, pubmedArticle := range pubmedArticleArray {
			dbArticle := pubmedArticleToDbArticle(pubmedArticle)
			articleArray[i] = dbArticle
		}
		log.Println("-- transformer Sending chunk")
		articleChannel <- articleArray
	}
	close(articleChannel)
}

func articleAdder(articleChannel chan []*Article, done chan bool, db *gorm.DB, commitSize int) {
	log.Println("Start articleAdder")
	tx := db.Begin()
	t0 := time.Now()
	counter := 0
	for articleArray := range articleChannel {
		log.Println("-- Consuming chunk")
		log.Println(counter)
		log.Println(commitSize)
		for _, article := range articleArray {
			if article == nil {
				continue
			}

			counter = counter + 1
			if counter == commitSize {
				counter = 0
				tc0 := time.Now()
				tx.Commit()
				t1 := time.Now()
				fmt.Printf("++++++++++++ The commit took %v to run.\n", t1.Sub(tc0))
				fmt.Printf("++++++++++++ The call took %v to run.\n", t1.Sub(t0))
				t0 = time.Now()
				tx = db.Begin()
			}
			if err := tx.Create(article).Error; err != nil {
				tx.Rollback()
				log.Println("\\\\\\\\\\\\\\\\")
				log.Println(err)
				log.Printf("PMID=%d", article.Id)
				log.Fatal("\\\\\\\\\\\\\\\\")
			}
		}
	}
	db.Close()
	done <- true
}
